- errors = @message_errors.join('<br/>') unless @message_errors.empty?
- receiver = @message.receiver
- receiver_id = receiver.id
- html = errors ?  '' : escape_javascript(render(partial:'users/dialogues/list_dialogues_name', locals: { user: receiver } ))
- status = ''
- if errors
  - status = errors
- else
  - status = "Successfully posted the message."
  - if @message_thread_existed
    - status << "Dialogue <b>#{@message.message_thread.title}</b> already existed.Posted the message to that Dialogue."

:plain
  var errors = "#{errors}";
  var messageStatusBoxSelector = "#messageStatusBox_" + "#{receiver_id}";
  var dialoguesListingSpanSelector = "#dialoguesListing_" + "#{receiver_id}";
  if( (errors == '') || (errors == null) || (errors == undefined) ) {
    var messageBoxSelector = "#messageBox_" + "#{receiver_id}";
    var messageAreaSelector = messageBoxSelector + " " + "#message_content";
    var titleFieldSelector = messageBoxSelector + " " + "#message_thread_title";
    $(messageAreaSelector).val('');
    $(titleFieldSelector).val('');
    $(messageBoxSelector).hide();
    $(messageStatusBoxSelector).html("#{status}");
    // The ruby code was getting parsed even the if clause evaluated to false
    // thus moved the ruby code outside :plain filter and stored the HTML, in
    // case no errors found, to ruby variable html above
    $(dialoguesListingSpanSelector).html("#{html}");
    // In Select Dropdowns due to caching sometimes the older value remain selected
    // though the drop-down was re-rendered.To avoid this programatically selecting
    // here the Dialogues dropdown's first option.
    resetSelectDialoguesDropdown(dialoguesListingSpanSelector);
  } else {
    $(messageStatusBoxSelector).html(errors);
  }

