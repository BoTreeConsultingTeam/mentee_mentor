class User < ActiveRecord::Base
  include GeneralScopes
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable, :omniauthable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :email, :password, :password_confirmation, :remember_me
  # attr_accessible :title, :body
  attr_accessible :first_name, :last_name

  has_one :profile, dependent: :destroy
  accepts_nested_attributes_for :profile
  # To allow mass assignment for association having accepts_nested_attributes_for
  # enabled.
  attr_accessible :profile_attributes

  has_many :message_threads, foreign_key: 'starter_id'
  has_many :messages_received, class_name: 'Message', foreign_key: 'receiver_id'
  has_many :messages_sent, class_name: 'Message', foreign_key: 'sender_id'

  has_many :followings, class_name: 'FollowedFollowing', foreign_key: 'followed_id', dependent: :destroy
  # :source is used to specify the column of the related entity
  # (FollowedFollowing, in present case) against which JOIN will be made in the
  # query with source entity(User, in present case ).
  # For e.g. this would generate following query :
  # SELECT `users`.* FROM `users` INNER JOIN `followed_followings` ON `users`.`id` = `followed_followings`.`following_id`
  # WHERE `followed_followings`.`followed_id` = 4
  # (check the ON clause which is generated by taking into account the :source option value)
  has_many :followed_by, through: :followings, source: :following

  has_many :follows_users, class_name: 'FollowedFollowing', foreign_key: 'following_id', dependent: :destroy
  has_many :follows, through: :follows_users, source: :followed

  has_many :authentications, dependent: :delete_all

  has_many :user_resources
  has_many :resources, :through => :user_resources

  has_many :statuses, dependent: :destroy, order: "statuses.updated_at DESC"

  scope :unread_messages, lambda { |sender_id|
     joins(:messages_received).where(messages: { sender_id: sender_id }).reverse_order_by_date
  }

  # References for overriden eqll? and hash:
  # 1) http://shortrecipes.blogspot.in/2006/10/ruby-intersection-of-two-arrays-of.html
  # 2) http://www.ruby-forum.com/topic/181819
  def eql?(other)
    (other.kind_of?(self.class) && !self.id.nil? && self.id == other.id)
  end

  def hash
    self.id
  end

  def most_recent_status
    self.statuses.first
  end

  def other_users_except_me
    User.where("id != ?", self.id)
  end

  def connected_with
    (self.followed_by & self.follows)
  end

  def is_followed_by
    self.followed_by
  end

  def is_following
    self.follows
  end

  def can_follow
    (other_users_except_me - self.is_following)
  end

  def is_following?(user)
    self.is_following.collect { |followed_user| followed_user.id }.include?(user.id)
  end

  def is_connected_with?(user)
    self.connected_with.collect { |connected_user| connected_user.id }.include?(user.id)
  end

  def messages_received_from_user(sender_id, limit=0, order='ASC')
    arel = self.messages_received.where(messages: { sender_id: sender_id }).order(messages_order_clause(order))
    arel.limit(limit) if limit > 0
    arel.to_a
  end

  def most_recent_message_received_from_user(sender_id)
    messages_received_from_user(sender_id, 1, 'DESC').first
  end

  def messages_sent_to_user(receiver_id, limit=0, order='ASC')
    arel = self.messages_sent.where(messages: { receiver_id: receiver_id }).order(messages_order_clause(order))
    arel.limit(limit) if limit > 0
    arel.to_a
  end

  def messages_exchanged_with_user(user_id)
    return [] if user_id.nil?
    messages_received = messages_received_from_user(user_id)
    messages_sent = messages_sent_to_user(user_id)
    (messages_received + messages_sent).sort { |x, y| x.datetime <=> y.datetime }
  end

  def message_threads_exchanged_with(user_id)
    return [] if user_id.nil?

    message_thread_ids = messages_exchanged_with_user(user_id).collect do |message|
                            message.message_thread.id
                         end
    MessageThread.where(id: message_thread_ids).to_a
  end

  def message_threads_containing_received_messages
    # messages.id is included in GROUP BY clause to resolve the following error
    # ActiveRecord::StatementInvalid (PG::Error: ERROR:  column "messages.id" must appear in the GROUP BY clause or be used in an aggregate function
    # encountered when the application was deployed to Heroku
    message_threads_id_arr = self.messages_received.group("messages.message_thread_id, messages.id").collect { |message| message.message_thread.id }
    message_threads_id_arr.uniq!
    return [] if message_threads_id_arr.empty?
    MessageThread.where(id: message_threads_id_arr).order("updated_at DESC")
  end

  def message_threads
    received_messages_id_arr = self.messages_received.select("messages.id").collect { |received_message| received_message.id }
    sent_messages_id_arr = self.messages_sent.select("messages.id").collect { |sent_message| sent_message.id }
    all_messages_id_arr = (received_messages_id_arr + sent_messages_id_arr)
    MessageThread.joins(:messages).where(messages: { id: all_messages_id_arr }).order('message_threads.updated_at DESC').uniq
  end

  def messages_received_in_thread(message_thread, limit=0)
    return [] if message_thread.nil?
    arel = message_thread.messages.where(receiver_id: self.id)
    arel.limit(limit) if limit > 0
    arel.to_a
  end

  def unfollow(user_id)
    followed_following_obj = nil
    if self.follows_users.exists?(followed_id: user_id)
      followed_following_obj = self.follows_users.find_by_followed_id(user_id).delete
    end
    followed_following_obj
  end

  def name
    unless profile.nil?
      first_name = profile.first_name
      last_name = profile.last_name
    end

    first_name = self.first_name unless first_name.present?
    last_name = self.last_name unless last_name.present?

    if (first_name.present? and last_name.present?)
      [first_name, last_name].join(" ")
    elsif first_name.present?
      first_name
    else
      self.email
    end
  end

  def apply_omniauth(omniauth)
    user_info_hash = omniauth[:user_info]

    unless user_info_hash.empty?
      self.email = user_info_hash[:email]

      self.first_name = user_info_hash[:first_name]
      self.last_name = user_info_hash[:last_name]

      case omniauth[:provider]
        when 'facebook'
          #self.facebook = user_info_hash[:url]
          #self.photo = URI.parse(user_info_hash[:image]) if user_info_hash[:image]
      end
    end
  end

  def connected_to_linkedin?
    !authentications.find_by_provider("linkedin").nil?
  end

  private

  def messages_order_clause(order)
    "datetime #{order}"
  end

end
